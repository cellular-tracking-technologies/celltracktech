dplyr::bind_rows(apply(contents[,unname(which(sapply(contents, is.POSIXct)))], 2, timeset)))
contents <- data.frame(contents)
contents$station_id <- sensor
contents$path <- y
contents
print(names(contents))
if (!(any(tolower(names(contents))=="validated"))) {contents$validated <- NA}
contents
contents$RadioId <- as.integer(contents$RadioId)
contents$TagRSSI <- as.integer(contents$TagRSSI)
contents
if (length(which(!is.na(contents$NodeId))) > 0) {
nodeids <- contents$NodeId[which(!is.na(contents$NodeId))]
insertnew <- DBI::dbSendQuery(conn, paste("INSERT INTO ","nodes (node_id)"," VALUES ($1)
ON CONFLICT DO NOTHING",sep=""))
DBI::dbBind(insertnew, params=list(unique(nodeids)))
DBI::dbClearResult(insertnew)
}
if(length(which(nchar(contents$TagId) != 8)) > 0) {
contents <- contents[-which(nchar(contents$TagId) != 8),] #drop rows where TagId not 8 characters
}
contents
rssicheck <- aggregate(TagRSSI ~ TagId + Time + NodeId + RadioId, data = contents,  function(x) length(unique(x)))
!is.na(contents$NodeId)
which(!is.na(contents$NodeId))
dbDisconnect(conn)
source("~/Documents/R/api_run_owl.R")
source("~/Documents/R/api_run_owl.R")
source("~/Documents/R/api_run_owl.R")
source("~/Documents/R/api_run_owl.R")
i <- DBI::dbReadTable(conn, "ctt_project_station")
i
begin <- i[i$station_id==sensor,]$deploy_at
begin
length(begin)) == 0
length(begin) == 0
as.POSIXct("2010-01-01")
source("~/Documents/R/api_run_owl.R")
source("~/Documents/R/api_run_owl.R")
source("~/Documents/R/api_run_owl.R")
dbDisconnect(conn)
source("~/Documents/R/api_run_owl.R")
dbDisconnect(conn)
source("~/Documents/R/api_run_owl.R")
db_cleanup <- function(conn) {
DBI::dbExecute(conn, "WITH ordered AS (
SELECT id, time, tag_id, node_id, tag_rssi,
rank() OVER (PARTITION BY time, tag_id, node_id, tag_rssi  ORDER BY id) AS rnk
FROM raw where node_id is not null
),
to_delete AS (
SELECT *
FROM   ordered
WHERE  rnk > 1
)
delete from raw using to_delete where raw.id = to_delete.id")
DBI::dbExecute(conn, "WITH ordered AS (
SELECT id, time, tag_id, node_id, tag_rssi,
rank() OVER (PARTITION BY time, tag_id, node_id  ORDER BY id) AS rnk
FROM raw where node_id is not null
),
to_delete AS (
SELECT *
FROM   ordered
WHERE  rnk > 1
)
delete from raw using to_delete where raw.time = to_delete.time and raw.node_id = to_delete.node_id and raw.tag_id =to_delete.tag_id") #2022-04-04 19:43:43-04 1933552D 377c59
}
db_cleanup(conn)
conn
conn <- dbConnect(RPostgres::Postgres(), dbname=db_name)
db_cleanup(conn)
myproject = "Burrowing Owl Project"
outpath
e <- "~/Documents/data/radio_projects/Lauren/test/Burrowing Owl Project/292DEF8A1720/raw/CTT-292DEF8A1720-raw-data.2022-04-05_024530.csv.gz"
y <- tail(unlist(strsplit(e, "/")), n=1)
splitfile <- unlist(strsplit(y, "CTT-"))
fileinfo <- splitfile[2]
sensorid <- unlist(strsplit(fileinfo,"-"))
sensor <- sensorid[1]
sensor
begin <- as.POSIXct("2010-01-01")
filenameinfo <- sensorid[2]
file_info <- unlist(strsplit(filenameinfo, "\\."))[1]
filetype <- ifelse(is.na(as.integer(file_info)),file_info,"sensorgnome")
filetype
filetype %in% c("raw", "node_health", "gps")
if (file.size(e) > 0) {
readr::read_csv(e, col_names = TRUE)
}}, error = function(err) {
contents <- tryCatch({
if (file.size(e) > 0) {
readr::read_csv(e, col_names = TRUE)
}}, error = function(err) {
return(NULL)
})
!is.null(contents)
delete.columns <- grep("[[:digit:]]", colnames(contents))
if (length(delete.columns) > 0) {
#what if the 1st row of the headerless file has the problem?
contents <- rbind(contents,Correct_Colnames(contents))
}
filetype == "raw"
if (length(delete.columns) > 0) {
if(ncol(contents) > 5) {
names(contents) <- c("Time","RadioId","TagId","TagRSSI","NodeId","Validated")
} else {names(contents) <- c("Time","RadioId","TagId","TagRSSI","NodeId")}
}
v <- ifelse(any(colnames(contents)=="Validated"), 2, 1)
correct <- ifelse(v < 2, 5, 6)
indx <- count.fields(e, sep=",")
if(any(indx != correct)) {
rowfix <- which(indx != correct) - 1
rowlen <- indx[which(indx != correct)] #what if this is more than 1 row?
if(length(rowfix) < 2) {
contents[rowfix,] <- fixrow(rowlen,rowfix,e,correct,DatePattern)
} else {
fixed <- Map(fixrow, rowlen, rowfix, MoreArgs=list(e=e, DatePattern=DatePattern, correct=correct))
fixed <- data.table::rbindlist(fixed, use.names=FALSE)
contents[rowfix,] <- fixed
}
}
contents
filetype
conn
sensor
y
begin
e
readin=e
readin
print(filetype)
print(str(contents))
print(begin)
if("Time" %in% colnames(contents)) {
if(is.character(contents$Time)) { #does this just handle 1 broken date? if so, what happens when there are more broken rows?
DatePattern = '[[:digit:]]{4}-[[:digit:]]{2}-[[:digit:]]{2}[T, ][[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2}(.[[:digit:]]{3})?[Z]?'
exactDatePattern = '^[[:digit:]]{4}-[[:digit:]]{2}-[[:digit:]]{2}[T, ][[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2}(.[[:digit:]]{3})?[Z]?$'
brokenrow <- grep(exactDatePattern, contents$Time, invert=TRUE) #find row that has a date embedded in a messed up string (i.e. interrupted rows)
contents[brokenrow,1]<- substring(contents[brokenrow,1], regexpr(DatePattern, contents[brokenrow,1]))
contents$Time <- as.POSIXct(contents$Time)
contents <- dplyr::filter(contents, Time < Sys.time() & Time > begin)
} else {
contents <- dplyr::filter(contents, Time < Sys.time() & Time > begin)
}
print(contents)
#contents <- contents[contents$Time < Sys.time() & contents$Time > begin,]
}
contents[,unname(which(sapply(contents, is.POSIXct)))] <- ifelse(nrow(contents[,unname(which(sapply(contents, is.POSIXct)))]) > 1,
tibble::as_tibble(apply(contents[,unname(which(sapply(contents, is.POSIXct)))], 2,
timeset)),
dplyr::bind_rows(apply(contents[,unname(which(sapply(contents, is.POSIXct)))], 2, timeset)))
contents <- data.frame(contents)
contents$station_id <- sensor
contents$path <- y
!is.null(contents)
filetype == "raw"
if (!(any(tolower(names(contents))=="validated"))) {contents$validated <- NA}
contents$RadioId <- as.integer(contents$RadioId)
contents$TagRSSI <- as.integer(contents$TagRSSI)
length(which(!is.na(contents$NodeId))) > 0
nodeids <- contents$NodeId[which(!is.na(contents$NodeId))]
nodecheck <- contents[!is.na(contents$NodeId),]
nrow(nodecheck[duplicated(nodecheck[c("Time", "TagId", "NodeId")]),]) > 0
rssicheck <- aggregate(TagRSSI ~ Time + TagId + NodeId, data = nodecheck, function(x) length(unique(x)))
badrec <- rssicheck[rssicheck$TagRSSI > 1,]
nrow(badrec) > 0
badrec
row 1
row <- 1
which(contents$Time == badrec$Time[row] & contents$TagId == badrec$TagId[row] & contents$NodeId == badrec$NodeId[row])
test <- which(contents$Time == badrec$Time[row] & contents$TagId == badrec$TagId[row] & contents$NodeId == badrec$NodeId[row])
contents[test,]
contents <- contents[-which(contents$Time == badrec$Time[row] & contents$TagId == badrec$TagId[row] & contents$NodeId == badrec$NodeId[row]),]
contents[test,]
contents[contents$TagId=='3452554B',]
contents[contents$TagId=='3452554B' & contents$NodeId == '33cfeb',]
if(nrow(badrec) > 0) {
for (row in nrow(badrec)) {
contents <- contents[-which(contents$Time == badrec$Time[row] & contents$TagId == badrec$TagId[row] & contents$NodeId == badrec$NodeId[row]),]
}
} else {
contents <- rbind(contents[is.na(contents$NodeId),],nodecheck[!duplicated(nodecheck[c("Time", "TagId","NodeId")]),])
}
contents
contents[contents$TagId == '1933552D',]
contents[contents$TagId == '1933552D' & contents$NodeId == '377c59',]
badrec
if(nrow(nodecheck[duplicated(nodecheck[c("Time", "TagId", "NodeId")]),]) > 0) {
rssicheck <- aggregate(TagRSSI ~ Time + TagId + NodeId, data = nodecheck, function(x) length(unique(x)))
badrec <- rssicheck[rssicheck$TagRSSI > 1,]
if(nrow(badrec) > 0) {
for (row in nrow(badrec)) {
contents <- contents[-which(contents$Time == badrec$Time[row] & contents$TagId == badrec$TagId[row] & contents$NodeId == badrec$NodeId[row]),]
}
} else {
contents <- rbind(contents[is.na(contents$NodeId),],nodecheck[!duplicated(nodecheck[c("Time", "TagId","NodeId")]),])
}
}
contents[contents$TagId == '1933552D' & contents$NodeId == '377c59',]
contents
nodecheck
badrec <- nodecheck[duplicated(nodecheck[c("Time", "TagId", "NodeId")]),]
badrec
nodecheck <- nodecheck[!duplicated(nodecheck[c("Time", "TagId", "NodeId", "TagRSSI")]),]
badrec <- nodecheck[duplicated(nodecheck[c("Time", "TagId", "NodeId")]),]
badrec
nodecheck[!nodecheck == badrec]
nodecheck[!nodecheck %in% badrec]
dbDisconnect(conn)
source("~/Documents/R/api_run_owl.R")
nodecheck
badrec <- nodecheck[nodecheck$NodeId=="jmdfhdk",]
badrec
e
nodecheck <- nodecheck[!nodecheck %in% badrec]
nodecheck
source("~/Documents/R/api_run_owl.R")
contents <- tryCatch({
readr::read_csv(e, col_names = TRUE)
}, error = function(err) {
return(NULL)
})
delete.columns <- grep("[[:digit:]]", colnames(contents), perl=T)
if (length(delete.columns) > 0) {
newcontents <- tryCatch({
rbind(contents,Correct_Colnames(contents))
}, error = function(err) {
return(contents)
})
contents <- newcontents
}
if (length(delete.columns) > 0) {
if(ncol(contents) > 5) {
names(contents) <- c("Time","RadioId","TagId","TagRSSI","NodeId","Validated")
} else {names(contents) <- c("Time","RadioId","TagId","TagRSSI","NodeId")}
}
v <- ifelse(any(colnames(contents)=="Validated"), 2, 1)
correct <- ifelse(v < 2, 5, 6)
indx <- count.fields(file.path(outpath, basename, sensor, filetype, y), sep=",")
if(any(indx != correct)) {
rowfix <- which(indx != correct) - 1
rowlen <- indx[which(indx != correct)] #what if this is more than 1 row?
if(length(rowfix) < 2) {
contents[rowfix,] <- fixrow(rowlen,rowfix,e,correct,DatePattern)
} else {
fixed <- Map(fixrow, rowlen, rowfix, MoreArgs=list(e=e, DatePattern=DatePattern, correct=correct))
fixed <- data.table::rbindlist(fixed, use.names=FALSE)
contents[rowfix,] <- fixed
}
}
if("Time" %in% colnames(contents)) {
if(is.character(contents$Time)) { #does this just handle 1 broken date? if so, what happens when there are more broken rows?
DatePattern = '[[:digit:]]{4}-[[:digit:]]{2}-[[:digit:]]{2}[T, ][[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2}(.[[:digit:]]{3})?[Z]?'
exactDatePattern = '^[[:digit:]]{4}-[[:digit:]]{2}-[[:digit:]]{2}[T, ][[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2}(.[[:digit:]]{3})?[Z]?$'
brokenrow <- grep(exactDatePattern, contents$Time, invert=TRUE) #find row that has a date embedded in a messed up string (i.e. interrupted rows)
contents[brokenrow,1]<- substring(contents[brokenrow,1], regexpr(DatePattern, contents[brokenrow,1]))
contents$Time <- as.POSIXct(contents$Time)
contents <- dplyr::filter(contents, Time < Sys.time() & Time > begin)
} else {
contents <- dplyr::filter(contents, Time < Sys.time() & Time > begin)
}
print(contents)
#contents <- contents[contents$Time < Sys.time() & contents$Time > begin,]
}
contents[,unname(which(sapply(contents, is.POSIXct)))] <- ifelse(nrow(contents[,unname(which(sapply(contents, is.POSIXct)))]) > 1,
tibble::as_tibble(apply(contents[,unname(which(sapply(contents, is.POSIXct)))], 2,
timeset)),
dplyr::bind_rows(apply(contents[,unname(which(sapply(contents, is.POSIXct)))], 2, timeset)))
contents <- data.frame(contents)
contents$station_id <- sensor
contents$path <- y
if (!(any(tolower(names(contents))=="validated"))) {contents$validated <- NA}
contents$RadioId <- as.integer(contents$RadioId)
contents$TagRSSI <- as.integer(contents$TagRSSI)
length(which(!is.na(contents$NodeId))) > 0
nodeids <- contents$NodeId[which(!is.na(contents$NodeId))]
nodecheck <- contents[!is.na(contents$NodeId),]
nodecheck <- nodecheck[!duplicated(nodecheck[c("Time", "TagId", "NodeId", "TagRSSI")]),]
nodecheck
badrec <- nodecheck[duplicated(nodecheck[c("Time", "TagId", "NodeId")]),]
badrec
nodecheck <- nodecheck[!nodecheck %in% badrec]
nodecheck[nodecheck$TagId=="1933552D",]
nodecheck[nodecheck$TagId=="1933552D" & nodecheck$TagRSSI==-94,]
nodecheck <- nodecheck[!nodecheck %in% badrec,]
nodecheck[nodecheck$TagId=="1933552D" & nodecheck$TagRSSI==-94,]
nodecheck[734,]
badrec[734,]
dbDisconnect(conn)
source("~/Documents/R/api_run_owl.R")
contents <- tryCatch({
if (file.size(e) > 0) {
readr::read_csv(e, col_names = TRUE)
}}, error = function(err) {
return(NULL)
})
delete.columns <- grep("[[:digit:]]", colnames(contents))
if (length(delete.columns) > 0) {
#what if the 1st row of the headerless file has the problem?
contents <- rbind(contents,Correct_Colnames(contents))
}
if (length(delete.columns) > 0) {
if(ncol(contents) > 5) {
names(contents) <- c("Time","RadioId","TagId","TagRSSI","NodeId","Validated")
} else {names(contents) <- c("Time","RadioId","TagId","TagRSSI","NodeId")}
}
v <- ifelse(any(colnames(contents)=="Validated"), 2, 1)
correct <- ifelse(v < 2, 5, 6)
indx <- count.fields(e, sep=",")
if(any(indx != correct)) {
rowfix <- which(indx != correct) - 1
rowlen <- indx[which(indx != correct)] #what if this is more than 1 row?
if(length(rowfix) < 2) {
contents[rowfix,] <- fixrow(rowlen,rowfix,e,correct,DatePattern)
} else {
fixed <- Map(fixrow, rowlen, rowfix, MoreArgs=list(e=e, DatePattern=DatePattern, correct=correct))
fixed <- data.table::rbindlist(fixed, use.names=FALSE)
contents[rowfix,] <- fixed
}
}
if("Time" %in% colnames(contents)) {
if(is.character(contents$Time)) { #does this just handle 1 broken date? if so, what happens when there are more broken rows?
DatePattern = '[[:digit:]]{4}-[[:digit:]]{2}-[[:digit:]]{2}[T, ][[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2}(.[[:digit:]]{3})?[Z]?'
exactDatePattern = '^[[:digit:]]{4}-[[:digit:]]{2}-[[:digit:]]{2}[T, ][[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2}(.[[:digit:]]{3})?[Z]?$'
brokenrow <- grep(exactDatePattern, contents$Time, invert=TRUE) #find row that has a date embedded in a messed up string (i.e. interrupted rows)
contents[brokenrow,1]<- substring(contents[brokenrow,1], regexpr(DatePattern, contents[brokenrow,1]))
contents$Time <- as.POSIXct(contents$Time)
contents <- dplyr::filter(contents, Time < Sys.time() & Time > begin)
} else {
contents <- dplyr::filter(contents, Time < Sys.time() & Time > begin)
}
print(contents)
#contents <- contents[contents$Time < Sys.time() & contents$Time > begin,]
}
contents[,unname(which(sapply(contents, is.POSIXct)))] <- ifelse(nrow(contents[,unname(which(sapply(contents, is.POSIXct)))]) > 1,
tibble::as_tibble(apply(contents[,unname(which(sapply(contents, is.POSIXct)))], 2,
timeset)),
dplyr::bind_rows(apply(contents[,unname(which(sapply(contents, is.POSIXct)))], 2, timeset)))
contents <- data.frame(contents)
contents$station_id <- sensor
contents$path <- y
if (!(any(tolower(names(contents))=="validated"))) {contents$validated <- NA}
contents$RadioId <- as.integer(contents$RadioId)
contents$TagRSSI <- as.integer(contents$TagRSSI)
nodeids <- contents$NodeId[which(!is.na(contents$NodeId))]
nodecheck <- contents[!is.na(contents$NodeId),]
nodecheck <- nodecheck[!duplicated(nodecheck[c("Time", "TagId", "NodeId", "TagRSSI")]),]
badrec <- nodecheck[duplicated(nodecheck[c("Time", "TagId", "NodeId")]),]
badrec
row <- 1
which(nodecheck$Time == badrec$Time[row] & nodecheck$TagId == badrec$TagId[row] & nodecheck$NodeId == badrec$NodeId[row])
test <- which(nodecheck$Time == badrec$Time[row] & nodecheck$TagId == badrec$TagId[row] & nodecheck$NodeId == badrec$NodeId[row])
nodecheck[test,]
nodecheck <- nodecheck[-which(nodecheck$Time == badrec$Time[row] & nodecheck$TagId == badrec$TagId[row] & nodecheck$NodeId == badrec$NodeId[row]),]
nodecheck[test,]
which(nodecheck$Time == badrec$Time[row] & nodecheck$TagId == badrec$TagId[row] & nodecheck$NodeId == badrec$NodeId[row])
if (nrow(badrec) > 0) {
for (row in nrow(badrec)) {
nodecheck <- nodecheck[-which(nodecheck$Time == badrec$Time[row] & nodecheck$TagId == badrec$TagId[row] & nodecheck$NodeId == badrec$NodeId[row]),]
}
}
nodecheck
badrec[badrec$TagId=="1933552D",]
if (nrow(badrec) > 0) {
for (row in nrow(badrec)) {
print(badrec[row,])
nodecheck <- nodecheck[-which(nodecheck$Time == badrec$Time[row] & nodecheck$TagId == badrec$TagId[row] & nodecheck$NodeId == badrec$NodeId[row]),]
}
}
for (row in nrow(badrec)) {
print(badrec[row,])
nodecheck <- nodecheck[-which(nodecheck$Time == badrec$Time[row] & nodecheck$TagId == badrec$TagId[row] & nodecheck$NodeId == badrec$NodeId[row]),]
}
nrow(badrec)
seq_along(nrow(badrec))
seq_along(1:nrow(badrec))
source("~/Documents/R/api_run_owl.R")
source("~/Documents/R/api_run_owl.R")
dbDisconnect(conn)
contents <- tryCatch({
if (file.size(e) > 0) {
readr::read_csv(e, col_names = TRUE)
}}, error = function(err) {
return(NULL)
})
delete.columns <- grep("[[:digit:]]", colnames(contents))
if (length(delete.columns) > 0) {
#what if the 1st row of the headerless file has the problem?
contents <- rbind(contents,Correct_Colnames(contents))
}
if (length(delete.columns) > 0) {
if(ncol(contents) > 5) {
names(contents) <- c("Time","RadioId","TagId","TagRSSI","NodeId","Validated")
} else {names(contents) <- c("Time","RadioId","TagId","TagRSSI","NodeId")}
}
v <- ifelse(any(colnames(contents)=="Validated"), 2, 1)
correct <- ifelse(v < 2, 5, 6)
indx <- count.fields(e, sep=",")
if(any(indx != correct)) {
rowfix <- which(indx != correct) - 1
rowlen <- indx[which(indx != correct)] #what if this is more than 1 row?
if(length(rowfix) < 2) {
contents[rowfix,] <- fixrow(rowlen,rowfix,e,correct,DatePattern)
} else {
fixed <- Map(fixrow, rowlen, rowfix, MoreArgs=list(e=e, DatePattern=DatePattern, correct=correct))
fixed <- data.table::rbindlist(fixed, use.names=FALSE)
contents[rowfix,] <- fixed
}
}
if("Time" %in% colnames(contents)) {
if(is.character(contents$Time)) { #does this just handle 1 broken date? if so, what happens when there are more broken rows?
DatePattern = '[[:digit:]]{4}-[[:digit:]]{2}-[[:digit:]]{2}[T, ][[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2}(.[[:digit:]]{3})?[Z]?'
exactDatePattern = '^[[:digit:]]{4}-[[:digit:]]{2}-[[:digit:]]{2}[T, ][[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2}(.[[:digit:]]{3})?[Z]?$'
brokenrow <- grep(exactDatePattern, contents$Time, invert=TRUE) #find row that has a date embedded in a messed up string (i.e. interrupted rows)
contents[brokenrow,1]<- substring(contents[brokenrow,1], regexpr(DatePattern, contents[brokenrow,1]))
contents$Time <- as.POSIXct(contents$Time)
contents <- dplyr::filter(contents, Time < Sys.time() & Time > begin)
} else {
contents <- dplyr::filter(contents, Time < Sys.time() & Time > begin)
}
print(contents)
#contents <- contents[contents$Time < Sys.time() & contents$Time > begin,]
}
contents[,unname(which(sapply(contents, is.POSIXct)))] <- ifelse(nrow(contents[,unname(which(sapply(contents, is.POSIXct)))]) > 1,
tibble::as_tibble(apply(contents[,unname(which(sapply(contents, is.POSIXct)))], 2,
timeset)),
dplyr::bind_rows(apply(contents[,unname(which(sapply(contents, is.POSIXct)))], 2, timeset)))
contents <- data.frame(contents)
contents$station_id <- sensor
contents$path <- y
print(names(contents))
if (!(any(tolower(names(contents))=="validated"))) {contents$validated <- NA}
contents$RadioId <- as.integer(contents$RadioId)
contents$TagRSSI <- as.integer(contents$TagRSSI)
nodeids <- contents$NodeId[which(!is.na(contents$NodeId))]
nodecheck <- contents[!is.na(contents$NodeId),]
nodecheck <- nodecheck[!duplicated(nodecheck[c("Time", "TagId", "NodeId", "TagRSSI")]),]
badrec <- nodecheck[duplicated(nodecheck[c("Time", "TagId", "NodeId")]),]
nodecheck2 <- nodecheck
if (nrow(badrec) > 0) {
for (row in seq_along(1:nrow(badrec))) {
print(badrec[row,])
nodecheck <- nodecheck[-which(nodecheck$Time == badrec$Time[row] & nodecheck$TagId == badrec$TagId[row] & nodecheck$NodeId == badrec$NodeId[row]),]
}
}
nodecheck
nodecheck2$id <- paste(nodecheck$Time, nodecheck$TagId, nodecheck$NodeId)
nodecheck2$id <- paste(nodecheck2$Time, nodecheck2$TagId, nodecheck2$NodeId)
nodecheck
nodecheck2
badrec$id <- paste(badrec$Time, badrec$TagId, badrec$NodeId)
badrec
!nodecheck2$id %in% badrec$id
which(!nodecheck2$id %in% badrec$id)
nodecheck[which(!nodecheck2$id %in% badrec$id),]
nodecheck[which(!nodecheck2$id %in% badrec$id) & !is.na(nodecheck$Time),]
nodecheck2[which(!nodecheck2$id %in% badrec$id) & !is.na(nodecheck2$Time),]
nodecheck2[which(!nodecheck2$id %in% badrec$id),]
badrec$id
nodecheck2[nodecheck2$Time == as.POSIXct("2022-04-05 00:44:41 UTC")]
nodecheck2[nodecheck2$Time == as.POSIXct("2022-04-05 00:44:41")]
nodecheck2[nodecheck2$Time == as.POSIXct("2022-04-05 00:44:41"),]
apply(badrec,1,function(x) print(x))
apply(badrec,1,function(x) print(x$Time))
apply(badrec,1,function(x) print(x[1]))
apply(badrec,1,function(x) print(str(x[1])))
apply(badrec[1,],1,function(x) print(str(x[1])))
apply(badrec[1,],1,function(x) print(unname(x[1])))
apply(badrec[1,],1,function(x) print(unname(x[1][1])))
apply(badrec[1,],1,function(x) print(unname(x[[1]])))
apply(badrec[1,],1,function(x) print(unname(x)))
apply(badrec[1,],1,function(x) print(unlist(x))
)
apply(badrec[1,],1,function(x) print(x[1,1])
)
apply(badrec[1,],1,function(x) print(x[[1]])
)
apply(badrec[1,],1,function(x) print(x[[1]][1]))
apply(badrec[1,],1,function(x) print(x[[1]][[1]]))
apply(badrec[1,],1,function(x) print(unname(x[[1]][[1]])))
apply(badrec[1,],1,function(x) print(str(unname(x[[1]][[1]]))))
apply(badrec[1,],1,function(x) print(str(unname(x[[1]][[1]][1]))))
apply(badrec[1,],1,function(x) print(x))
apply(badrec[1,],1,function(x) print(x[names(x)=="Time"]))
apply(badrec[1,],1,function(x) print(x[names(x)=="Time"][2]))
apply(badrec[1,],1,function(x) print(x[names(x)=="Time"][1]))
apply(badrec[1,],1,function(x) print(x[names(x)=="Time"][[1]]))
apply(badrec[1,],1,function(x) print(x[names(x)=="Time"][[1]][[1]]))
apply(badrec[1,],1,function(x) print(x[names(x)=="Time"][[1]][[2]]))
apply(badrec[1,],1,function(x) print(x[names(x)=="Time"][[1]][[1]]))
apply(badrec[1,],1,function(x) print(x[names(x)=="Time"][[1]][[1]][[1]]))
apply(badrec[1,],1,function(x) print(x[names(x)=="Time"][[1]][[1]][[1]][[1]]))
apply(badrec[1,],1,function(x) print(nodecheck[nodecheck$Time==as.POSIXct(x[1]),]))
apply(badrec[1,],1,function(x) print(names(x[1])))
apply(badrec[1,],1,function(x) print(x[1,1]))
apply(badrec[1,],1,function(x) print(x[1]))
apply(badrec[1,],1,function(x) print(x[1]$Time))
apply(badrec[1,],1,function(x) print(x[1]["Time"]))
apply(badrec[1,],1,function(x) print(dim(x[1]["Time"])))
apply(badrec[1,],1,function(x) print(x[1]["Time"]))
apply(badrec[1,],1,function(x) print(unname(x[1]["Time"])))
apply(badrec[1,],1,function(x) print(unname(x[1]["Time"])[1]))
apply(badrec[1,],1,function(x) print(unname(x[1]["Time"])[[1]]))
apply(badrec[1,],1,function(x) print(unname(x[1]["Time"])[1]))
apply(badrec[1,],1,function(x) print(x["Time"]))
source("~/Documents/R/api_run_owl.R")
source("~/Documents/R/api_run_owl.R")
devtools::document()
setwd("~/Documents/celltracktech")
devtools::document()
devtools::update_packages("celltracktech")
